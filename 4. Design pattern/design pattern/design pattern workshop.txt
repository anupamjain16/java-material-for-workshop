megha genpact
aashish
mongoDB Java 9 session

workshop design pattern using java:
----------------------------------

	=> What and Why design pattern

	=> loose coupling and high cohesion, using interface, 
	composition, aggrigation, inheritance, basic of uml
 
	=> Design Principles (SOLID)

	=> Design Principles ( GRASP)

	=> GOF Pattern categories:  Creational, Structural, Behavioral

	=> Creational Patterns
		Singleton
		Factory
		Abstract Factory
		Builder
		Prototype

	=> Structural Patterns
		Adapter
		Decorator
		Facade Pattern
		Bridge
		Composite
		Flyweight
		Proxy

	=> Behavioral Patterns
		Chain of Responsibility
		Command
		Interpreter
		Iterator
		Mediator
		Memento
		Observer
		Strategy
		Template Method


What and Why design pattern
===========================

	==> GOF, 23 patterns

	==> Classification patterns: Creational, Structural, Behavioral


loose coupling and high cohesion, using interface
==================================================
	Examples


Design Principles (SOLID)
=========================
	Single Responsibility Principle
	Open Close Principle
	Liskov's Substitution Principle
	Dependency Inversion Principle
	Interface Segregation Principle
	


	Open Close Principle: SW entities ( classes, modules, functions) should be 		
	open for extension but closed for modification




Design Principles (GRASP):larman
===================================
	example shopping cart 

	
	public class Product {
		private String name;
		private double price;

	}
	
	public class Order {
	    private Product product;
	    private int quantity;
	}


	public class ShoppingCart {
	    private List<Order> orders = new ArrayList<Order>();
	
		public List<Order> getOrders() {
			return orders;
		}
	
		public void addOrder(Order order) {
			this.orders.add(order);
		}   
	    
	}



main:
-----------
	Product p1 = new Product();
		Product p2 = new Product();
		p1.setPrice(1000);
		p2.setPrice(2000);
		Order o1 = new Order();
		Order o2 = new Order();
		o1.setProduct(p1);
		o1.setQuantity(5);
		o2.setProduct(p2);
		o2.setQuantity(5);
		ShoppingCart cart = new ShoppingCart();
		cart.addOrder(o1);
		cart.addOrder(o2);





GOF Pattern categories:  Creational, Structural, Behavioral
============================================================


Creational Pattern
==================

	==> What is the best way to create object?

	==> Creational Pattern

		=> Factory Pattern 
		=> Abstract Factory Pattern (Factory of Factory pattern)
		=> Singleton Pattern
		=> Prototype Pattern
		=> Builder Pattern




structural patterns 
======================

	==> Structural Patterns describe how objects and 
		classes can be combined to form larger structures

	==> class patterns vs object patterns

	==> The difference between class patterns and object patterns is that 
		class patterns describe abstraction with the help of inheritance
		and how it can be used to provide more useful program interface. 

	==> Object patterns, on other hand, describe how objects can
		 be associated and composed to form larger, more complex structures

	
	==> structural patterns 

		=> Adapter Pattern
		=> Composite Pattern
		=> Decorator Pattern :io
		=> Facade Pattern 
		=> Flyweight Pattern 
		=> Proxy Pattern



Behavioral Patterns
===================

	==> Behavioural patterns are those which are concerned with 
		interactions between the objects.

	==> The interactions between the objects should be such that they 
	  are talking to each other and still are loosely coupled. 


	==> The loose coupling is the key to n-tier architectures. 
		In this, the implementation and the client should be loosely 
		coupled in order to avoid hard-coding and dependencies.


	==> Behavioral Patterns
		=> Strategy Pattern
		=> Command Pattern
		=> Chain of Responsibility Pattern
		=> Interpreter Pattern
		=> Iterator Pattern
		=> Mediator Pattern
		=> Observer Pattern 
		=> State Pattern
		=> Template Pattern
		=> Visitor Pattern


Creational Pattern
======================


	Simple Factory 
	===============

		if we have a super class and an sub-classes, and based on data provided, 
		we have to return the object of one of the sub-classes, we use a simple factory

	Example:

	class Person {
    		private String name;
   		 private String gender;

		//getter setter
	}



	class Female extends Person {
   		 public Female(String fullname){
      			  System.out.println("Hello Ms " + fullname);
    		}
	}



	class Male extends Person {
    		public Male(String fullname){
      			  System.out.println("Hello Mr " + fullname);
    		}

	}


	class PersonFactory{
		static Person getPerson(String gender, String name){
        		if(gender.equals("M"))
           			 return new Male(name);
       		      else if(gender.equals("F"))
            			return new Female(name);
        		else 
            		return null;
		  }
       }


	
	==> examples (factory design pattern)
	
		=>Calendar calendar = Calendar.getInstance();
		System.out.println(calendar);

		=> createStatement() of java.sql.Connection interface

		=> createSocket() of java.rmi.server.RmiClientSocketFactory




	=> example connection factory: mysql/ db-derby
	---------------------------------
connect 'jdbc:derby://localhost:1527/demodb;create=true;user=root;password=root';



db.properties
-------------------

driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/bookapp
user=root
password=root


db-derby.properties
-------------------
driver=org.apache.derby.jdbc.ClientDriver
url=jdbc:derby://localhost:1527/demodb
user=root
password=root


Create an connection factory
-------------------------


import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class ConnectionFactory{

    private static Connection connection = null;

    public static Connection getConnection() {
        if (connection != null)
            return connection;
        else {
            try {
                Properties prop = new Properties();
		//FileInputStream in = new FileInputStream
                InputStream inputStream = ConnectionFactory.class.getClassLoader().getResourceAsStream("db.properties");

                prop.load(inputStream);
                String driver = prop.getProperty("driver");
                String url = prop.getProperty("url");
                String user = prop.getProperty("user");
                String password = prop.getProperty("password");
                Class.forName(driver);
                connection = DriverManager.getConnection(url, user, password);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return connection;
        }

    }
}




	Factory Method pattern
	========================
	=> Defind an interface for creating an object, but let subclass decide which object to instantiate, 
		Factory method let a class defer instantiation to subclass using inheritance.

	Implementation:
	---------------
	=> provide an interface for creating an oblject here do not consider the word interface as java interface. 
	It simply mean to provides a contract / method to create an object

	=> let the subclass decide what exact object ot instantiate- This pattern involve "inheritance"

	=> let we write an batch file processor
	 steps: 1. open an file
		2. choose a parser
		3. use parser to get List of records
		4. process record ie put to db
		5. write summery
		6. close file


		File f=openFile(fileName);
		

	Attempt 1: Writing batch process for processing text file
	---------------------------------------------------------
	
	public class BatchProcessor {
	
		public void processBatch(String fileName) {
			File file = openFile();
			TextParser parser = new TextParser(file);
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}
	
		private void processorRecords(List<Record> records) {
			System.out.println("processing each record to db");
		}
	
		private void writeSummray() {
			System.out.println("writing summery report");
		}
	
		private void closeFile() {
			System.out.println("closing the file...");
		}
	
		private File openFile() {
			System.out.println("open the file...");
			return null;
		}
	}


	public class TextParser {
	
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	
	}


	public class Record {}


	public class Main {
		public static void main(String[] args) {
			
			BatchProcessor batchProcessor=new BatchProcessor();
			batchProcessor.processBatch("foo");		
		}
	}


	Attempt 2: Writing batch process for processing cvs file too...
	---------------------------------------------------------
	
	To cater the requirment i will create an interface:
	
	public interface Parser {
		public abstract List<Record> parse();
	}


	public class CVSParser implements Parser {
		public CVSParser(File file) {
			System.out.println("creating cvs parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using cvs parser...");
			return null;
		}
	
	}


	public class TextParser implements Parser {
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	}


	Now  i need to change BatchProcessor class and need to pass choice of parser: 


			public void processBatch(String fileName, String formete) {
			Parser parser=null;
			File file = openFile();
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
				
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}


	Attempt 3: Writing batch process for processing xml file too...
	---------------------------------------------------------
		public class XmlParser implements Parser {
		
		public XmlParser(File file) {
			System.out.println("creating xml parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using xml parser...");
			return null;
		}
	
	}



	Now again i need to change BatchProcessor class and need to pass choice of parser: 


			public void processBatch(String fileName, String formete) {
			Parser parser=null;
			File file = openFile();
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
				
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}


	=> clear voilation of OCP
	=> We are supposed to change BatchProcessor every now and then, can not do in case of api design 
	=> voilation of Dependency inversion: depend on abstraction

	Solution:
	---------
		=> this is not acceptable code:
		   ----------------------------
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
			else if(formete.equals("xml"))
				parser=new XmlParser(file);



		=> refactoring code:
		--------------------


	public void processBatch(String fileName, String formete) {
		Parser parser = null;
		File file = openFile();

		parser = createParser(file);
		List<Record> records = parser.parse();
		processorRecords(records);
		writeSummray();
		closeFile();

	}
	 abstract Parser createParser(File file);


		=> now its works as a framework for batch processing
		and we never have to change BatchProcessor for changing parser approach


	
	BatchProcessor batchProcessor=new TextBatchProcessor();
	batchProcessor.processBatch("foo","xml");
			
	https://stackoverflow.com/questions/13029261/
	design-patterns-factory-vs-factory-method-vs-abstract-factory/35851402#35851402

	Abstract Factory Pattern
	========================
	
	Singleton Pattern
	===================

	" one object per application" ex logging , db connection etc

	=> lazy vs eager
	=> threading issue, double locking
	=> What if clonned
	=> What if deserilized?
	=> What if used java reflection?
	=> what if 2 class loader load that class twice
	=> best practices, effective java
	=> using enum

	Attempt 1:

	class SingletonObject {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 2: What about race condition?

	
	class SingletonObject  {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 3: What if somebody make clone of Singleton object?

	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}



	Attempt 4: Double locking
		This optimization consist in checking in an unsynchronized block if
		 the object is null and if not to check again and create it in an syncronized block. 
		This is called double locking mechanism
	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static  SingletonObject getSingletonObject() {

			if (singletonObject == null){
			synchronized(SingletonObject.class)
			{
				if (singletonObject== null)
				{
					System.out.println("getInstance(): First time getInstance was invoked!");
					instance = new Singleton();
				}
			}            
		}

		return singletonObject;


		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}

	What if used reflection to create an object:
	--------------------------------------------
		Constructor[] constructors=Singleton.class.getDeclaredConstructors();
		constructors[0].setAccessible(true);
		s2=(Singleton) constructors[0].newInstance();


	What if serialization is done?

	protected Object readResolve() {
   		 return getInstance();
	}

Some imp concepts:
-------------------
=> enum
=> serilization and issues 
=> cloning : deep copy vs shallow copy
=> reflection



	More issues: http://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples

	Prototype Pattern (best practics for creating clone)
	===================================================

		=> About creating clone of an object

		=> Why clonning? cloning of an object to avoid creation

		=> If the cost of creating a new object is large and creation 
			is resource intensive, we clone the object

		=> We use the interface Cloneable and call its method clone() to clone the 			
			object

		=> Deep copy vs shallow copy

		=> Shallow copying generally means copying only one level of an object,
		 while deep copying generally means copying more than one level


	Ex:

	
//about what is the best practice to create clone of an object?

  class Employee implements Cloneable {
	private Integer id;
	private String name;
	private Date hireDay;//mutable

	public Employee(Integer id, String name, Date date) {
		super();
		this.id = id;
		this.name = name;
		this.hireDay=date;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", hireDay=" + hireDay
				+ "]";
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
		 // call Object.clone()
		 Employee cloned = (Employee) super.clone();

		// clone mutable fields
		 cloned.hireDay = (Date) hireDay.clone();

		 return cloned;
	}

	public void changeHireDay(int year, int month, int day){
		 hireDay.setDate(day);
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getHireDay() {
		return hireDay;
	}

	public void setHireDay(Date hireDay) {
		this.hireDay = hireDay;
	}
	
	
}

public class Demo {
	public static void main(String[] args) throws CloneNotSupportedException {
		Date date=new GregorianCalendar(2001, 11, 22).getTime();
		
		Employee employee1 = new Employee(33, "raja", date);
	
		Employee employee2 = (Employee) employee1.clone();
	
		System.out.println(employee1);
		System.out.println(employee2);
		
		System.out.println("After changing............");
		employee1.changeHireDay(2011, 11, 11);
		employee1.setName("amit");
		System.out.println(employee1);
		System.out.println(employee2);

	}

}




Builder Pattern
================

	==> The Builder pattern can be used to ease the construction 
	   of a complex object from simple objects

	public class Food {
		private String name;
		private int unit;
		private int vitC;
		private int vitA;
		private int vitB12;
		private int vitB5;
		private int vitD;

		//
		
	}
		
	public class FoodBuilder {
	
		private String name;
		private int unit;
		private int vitC=100;
		private int vitA=100;
		private int vitB12=100;
		private int vitB5=100;
		private int vitD=5000;
		public FoodBuilder(String name, int unit) {
			super();
			this.name = name;
			this.unit = unit;
		}
		
		
		public Food build(){
			return new Food(name, unit, vitC, vitA, vitB12, vitB5, vitD);
		}
	
	
		public FoodBuilder setName(String name) {
			this.name = name;
			return this;
		}

	}

	public class DemoBuilder {
	
		public static void main(String[] args) {
			Food food=new FoodBuilder("apple", 400).setVitA(5000).build();
		}
	}

	http://www.javaspecialists.eu/archive/Issue163.html





structural patterns 
============================
	Adapter Pattern 
	Decorator Pattern 
	Facade Pattern 
	proxy design pattern
	Composite Pattern 
	Bridge Pattern 
	Flyweight Pattern


Adapter Pattern
================
	==> It helps in integrating two modules with different incompatible interfaces. 
	==> The Adapter pattern is used so that two unrelated interfaces can work together
	==> The joining between them is called an Adapter. 
	==> This is something like we convert interface of one class into interface expected by the client. 
	==>  Way to implement adaper

		=> Using inheritance: A class adapter 
		=> User composition: An object adapter

	Use cases:
	----------
	1. Most important task of an Adapter is to transfer data between applications or modules.
	2. Very common task is to parse the information from one kind to the other
	3. Convert from one type to the other
	4. Some times adapters even validate the data so that right data flows into the application 
	from external applications.

	=> Having adapters help in keeping the conversion code separate so that the parsing functionality
	 is not leaking into the core modules of our application.

	=> Another important advantage of having an adapter is that when there is a 
	change in outside interface, our core modules does not get affected. 
	Only adapters need to be modified. So, this helps in restricting the changes to 
	 adapter module alone and rest of application does not get affected. 




	Convert the interface of a class into another interface clients expect. 
	Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.


	http://java.dzone.com/articles/design-patterns-uncovered-0



	Adapter Pattern hello world:
	----------------------------
	public class RoundPeg {
		public void insertTohole(String str) {
			System.out.println("roundpeg insertTohole(): " + str);
		}
	}

	public class SquarePeg {
		public void insert(String str) {
			System.out.println("SquarePeg insert(): " + str);
		}
	}



	// adaptoing roundpeg to square pag
	public class PegAdaptor extends SquarePeg  {
	
		private RoundPeg peg;
	
		public PegAdaptor(RoundPeg peg) {
			super();
			this.peg = peg;
		}
		
		public void insert(String str) {
			peg.insertTohole(str);
		}
	}



//adaptoing roundpeg to square pag
public class Demo {

	public static void main(String[] args) {
		
		RoundPeg peg=new RoundPeg();
		PegAdaptor adpt=new PegAdaptor(peg);
		adpt.insert("hello");
	}
}




decorator pattern / wrapper pattern 
=================================

	=> Decorator pattern helpful in adding behaviour to objects statically or dynamically.

	=> Decorator pattern helps in extending the functionality of the objects without
	 effecting the behaviour of other objects.

	=> Decorator adhering to the design principle of Open for extension and closed for modification

	=> In the Decorator pattern, a decorator object is wrapped around the original object

 	=> This is typically achieved having the original object as a member
		 of the decorator, with the decorator forwarding the 
		requests to the original object and also implementing the new functionality

	==> The decorator must conform to the interface of the original object
		 (the object being decorated) 


	=> Simple greet application:
	---------------------------------


		
	public interface Greet {
		public String greet();
	 }
		 
	public class SimpleGreet implements Greet {
		@Override
		public String greet() {
			return "morning";
		}
	}


	public class GreetDecorator implements Greet{
		private Greet greet;
	
		public GreetDecorator(Greet greet) {
			this.greet = greet;
		}
	
		@Override
		public String greet() {
			return "great"+ greet.greet();
		}
	
	}

	GreetDecorator decorator=new GreetDecorator(new SimpleGreet());
	decorator.greet();




composite design pattern:
----------------------------
	=> Composite pattern is used where we need to treat a 
	group of objects in similar way as a single object. 

	=> Composite pattern composes objects in term of a tree structure to represent 
		part as well as whole hierarchy.

	=> This pattern creates a class that contains group of its own objects. 
	This class provides ways to modify its group of same objects.


	Example: class Employee which acts as composite pattern actor class

public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates;

   // constructor
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List<Employee> getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return ("Employee :[ Name : " + name + ", dept : " + dept + ", salary :" + salary+" ]");
   }   
}





      Employee CEO = new Employee("John","CEO", 30000);

      Employee headSales = new Employee("Robert","Head Sales", 20000);

      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);

      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

      CEO.add(headSales);
      CEO.add(headMarketing);

      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);

      headMarketing.add(clerk1);
      headMarketing.add(clerk2);

      //print all employees of the organization
      System.out.println(CEO); 
      
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }		



proxy design pattern:
------------------
	=> Provide a surrogate or placeholder for another object to control access to it

	
	abstract class Subject {
		public abstract void doSomeWork();
	}
	
	class ConcreteSubject extends Subject {
		@Override
		public void doSomeWork() {
			System.out.println(" I am from concrete subject");
		}
	}
	
	class Proxy extends Subject {
		ConcreteSubject cs;
	
		@Override
		public void doSomeWork() {
			System.out.println("Proxy call happening now");
			// Lazy initialization
			if (cs == null) {
				cs = new ConcreteSubject();
			}
			cs.doSomeWork();
		}
	}
	
	public class Demo {
	
		public static void main(String[] args) {
			Proxy px = new Proxy();
			px.doSomeWork();
		}
	}




Example RMI:
=============



RMI server
-------------

public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}





public class AtomCardImp extends UnicastRemoteObject implements AtmCard,
		Serializable {

	protected AtomCardImp() throws RemoteException {
		super();
	}

	@Override
	public boolean isValid(String card) throws RemoteException {
		Integer val = Integer.parseInt(card);
		if (val % 2 == 0)
			return false;
		else
			return true;
	}

}



public class Server {
	public static void main(String[] args) throws RemoteException, AlreadyBoundException {
		AtomCardImp obj=new AtomCardImp();
		
		Registry registry=LocateRegistry.createRegistry(222);//pass port no
		registry.bind("obj", obj);
		System.out.println("service is bound!");
		
	}

}



RMI Client
-------------


public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}



public class RMIClient {
	public static void main(String[] args) throws RemoteException, NotBoundException {
		Registry registry=LocateRegistry.getRegistry("localhost", 222);
		AtmCard card=(AtmCard) registry.lookup("obj");
		
		System.out.println(card.isValid("121"));
		
	}

}



Bridge Pattern 
------------------
	=> decouple an abstraction from its implementation so 
	that the two can vary independently

	=> This type of design pattern comes under structural pattern as this pattern
	 decouples implementation class and abstract class by 
	providing a bridge structure between them.


======================
 Behavioral Patterns
======================

		Iterator
		Observer
		Strategy
		Chain of Responsibility
		Template design pattern
		Command
		Interpreter
		Mediator
		Memento
		


	Iterator design pattern:
	------------------------
	=> iterator pattern allows for the traversal through the elements
	 in a grouping of objects via a standardized interface. 

	=> An Iterator interface defines the actions that can be performed.

	=>  These actions include being able to traverse the objects and also obtain the objects


	Example : write our own iterator by implementing java.util.Iterator
		 hasNext(), next(), and remove() methods



public class Item {

	String name;
	float price;

	public Item(String name, float price) {
		this.name = name;
		this.price = price;
	}

	public String toString() {
		return name + ": $" + price;
	}
}



public class Menu {

	List<Item> menuItems;

	public Menu() {
		menuItems = new ArrayList<Item>();
	}

	public void addItem(Item item) {
		menuItems.add(item);
	}

	public Iterator<Item> iterator() {
		return new MenuIterator();
	}

	class MenuIterator implements Iterator<Item> {
		int currentIndex = 0;

		@Override
		public boolean hasNext() {
			if (currentIndex >= menuItems.size()) {
				return false;
			} else {
				return true;
			}
		}

		@Override
		public Item next() {
			return menuItems.get(currentIndex++);
		}

		@Override
		public void remove() {
			menuItems.remove(--currentIndex);
		}

	}

}


public class Demo {

	public static void main(String[] args) {

		Item i1 = new Item("mouse", 7.50f);
		Item i2 = new Item("laptop", 6.00f);
		Item i3 = new Item("DVD", 6.50f);

		Menu menu = new Menu();
		menu.addItem(i1);
		menu.addItem(i2);
		menu.addItem(i3);

		System.out.println("Displaying Menu:");
		Iterator<Item> iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

		System.out.println("\nRemoving last item returned");
		iterator.remove();

		System.out.println("\nDisplaying Menu:");
		iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

	}

}


Observer design pattern:
========================

	=> Observer pattern in java is one of the most important design patterns. 
	=> The concept behind the Observer design pattern is the basis for PubSub, event and non blocking based systems
	
	=> stock application
	
	public interface Observable {
		public void registerObserver(Observer observer);
		public void notifyObservers();
		public void removeObserver(Observer observer);
	}


	public interface Observer {	
		public void update(Stock stock);
	}




   public abstract class Stock implements Observable{
	private List<Observer> observers;
	
	public Stock(){
		observers = new ArrayList<Observer>();
	}
	
	private String name;
	private int price;
	
	public String getStockName(){
		return name;
	}

	@Override
	public void registerObserver(Observer observer) {
		if(observer != null){
			this.observers.add(observer);
		}
	}

	@Override
	public void notifyObservers() {
		Iterator<Observer> it = observers.iterator();
		while(it.hasNext()){
			Observer observer = it.next();
			observer.update(this);
		}
	}

	@Override
	public void removeObserver(Observer observer) {
		if(observer != null){
			this.observers.remove(observer);
		}
	}
	
	public int getStockPrice(){
		return price;
	}
	
	public void updateStockPrice(int updatedPrice){
		this.price = updatedPrice;
		this.notifyObservers();
	}
	
	public void setName(String stockName){
		this.name = stockName;
	}
}


	public class Mobile implements Observer{
		@Override
		public void update(Stock stock) {
			System.out.println("MOBILE - The Price of "+stock.getStockName()+" has changed:"+stock.getStockPrice());
		}
	}

	
	public class DisplayBoard implements Observer{
		@Override
		public void update(Stock stock) {
		System.out.println("DISPLAYBOARD - The Price of "+stock.getStockName()+" has changed:"+stock.getStockPrice());
		}
	}

	public class IBM extends Stock{
		public IBM(){
			this.setName("IBM");
		}
	}

	public class Apple extends Stock{
		public Apple(){
			this.setName("Apple");
		}
	}


	public class Microsoft extends Stock{
		public Microsoft(){
			this.setName("Microsoft");
		}
	}




	
	public class Exec {
		public static void main(String[] args) {
			//Create stocks
			IBM ibm = new IBM();
			Microsoft microsoft = new Microsoft();
			Apple apple = new Apple();
			
			//Create Observers
			Mobile mobile = new Mobile();
			DisplayBoard displayBoard = new DisplayBoard();
			
			//Register Observers for stocks
			ibm.registerObserver(mobile);
			ibm.registerObserver(displayBoard);
			
			microsoft.registerObserver(mobile);
			microsoft.registerObserver(displayBoard);
			
			apple.registerObserver(mobile);
			apple.registerObserver(displayBoard);
			
			//Set some random stock prices
			for(int i =0; i<300; i++){
				ibm.updateStockPrice((int)(Math.random()*101)+1);
				microsoft.updateStockPrice((int)(Math.random()*101)+1);
				apple.updateStockPrice((int)(Math.random()*101)+1);
			}
			
		}
	}







Jdk support for observer design pattern:
----------------------------------------

		//observable (news paper wala)
		public class MySubject extends Observable {
			private String name;
			private float price;
		
			public MySubject(String name, float price) {
				this.name = name;
				this.price = price;
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			public float getPrice() {
				return price;
			}
		
			public void setPrice(float price) {
				this.price = price;
				setChanged();
				notifyObservers(new Float(price));
			}
		
		}
		
		


			
			public class MyObserver  implements Observer{
				private float price;
				
				@Override
				public void update(Observable o, Object a) {
					
					price=(float) a;
					
					System.out.println("price observed : price changed to :"+price);
				}
			
			}





		MySubject subject=new MySubject("rice", 55);
		MyObserver o=new MyObserver();
		
		subject.addObserver(o);
		
		subject.setPrice(88);
		subject.setPrice(99);


	 

Chain of Responsibility
-----------------------

	=> used to achieve loose coupling in software design where a request 
	from client is passed to a chain of objects to process them. 

	=>Then the object in the chain will decide themselves who will 
	be processing the request and whether the request is 
	required to be sent to the next object in the chain or not.

	=> ex:  try-catch block

	=> Ex: ATM Dispense machine, 50$, 20$, 10$ etc




public class Currency {

	private int amount;
	
	public Currency(int amt){
		this.amount=amt;
	}
	
	public int getAmount(){
		return this.amount;
	}
}



public interface DispenseChain {

	void setNextChain(DispenseChain nextChain);
	
	void dispense(Currency cur);
}




public class Dollar50Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 50){
			int num = cur.getAmount()/50;
			int remainder = cur.getAmount() % 50;
			System.out.println("Dispensing "+num+" 50$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}





public class Dollar20Dispenser implements DispenseChain{

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 20){
			int num = cur.getAmount()/20;
			int remainder = cur.getAmount() % 20;
			System.out.println("Dispensing "+num+" 20$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}




public class Dollar10Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 10){
			int num = cur.getAmount()/10;
			int remainder = cur.getAmount() % 10;
			System.out.println("Dispensing "+num+" 10$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}



//  Creating the Chain
======================
public class ATMDispenseChain {

	private DispenseChain c1;

	public ATMDispenseChain() {
		// initialize the chain
		this.c1 = new Dollar50Dispenser();
		DispenseChain c2 = new Dollar20Dispenser();
		DispenseChain c3 = new Dollar10Dispenser();

		// set the chain of responsibility
		c1.setNextChain(c2);
		c2.setNextChain(c3);
	}

	public static void main(String[] args) {
		ATMDispenseChain atmDispenser = new ATMDispenseChain();
		while (true) {
			int amount = 0;
			System.out.println("Enter amount to dispense");
			Scanner input = new Scanner(System.in);
			amount = input.nextInt();
			if (amount % 10 != 0) {
				System.out.println("Amount should be in multiple of 10s.");
				return;
			}
			// process the request
			atmDispenser.c1.dispense(new Currency(amount));
		}

	}

}


template design pattern:
-------------------------
http://www.journaldev.com/1763/template-method-design-pattern-in-java


	=> Template Method is a behavioral design pattern. 

	=> Template Method design pattern is used to create a method stub and 		
		deferring some of the steps of implementation to the subclasses.

	=> Template method defines the steps to execute an algorithm and it
	 can provide default implementation that might be common for all or some of 		
		the subclasses.

	=> suppose we want to provide an algorithm to build a house. 
	The steps need to be performed to build a house are 
	 building foundation, building pillars, building walls and windows.

	=>  The important point is that the we cant change the order of execution
	 because we can't build windows before building the foundation.

	=> So in this case we can create a template method that will use different methods to build the house



public abstract class HouseTemplate {

	//template method, final so subclasses can't override
	public final void buildHouse(){
		buildFoundation();
		buildPillars();
		buildWalls();
		buildWindows();
		System.out.println("House is built.");
	}

	//default implementation
	private void buildWindows() {
		System.out.println("Building Glass Windows");
	}

	//methods to be implemented by subclasses
	public abstract void buildWalls();
	public abstract void buildPillars();

	private void buildFoundation() {
		System.out.println("Building foundation with cement,iron rods and sand");
	}
}



public class WoodenHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Wooden Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with Wood coating");
	}

}




public class GlassHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Glass Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with glass coating");
	}

}



		HouseTemplate houseType = new WoodenHouse();
		
		//using template method
		houseType.buildHouse();
		System.out.println("************");
		
		houseType = new GlassHouse();
		
		houseType.buildHouse();



	Example in jdk:
	-----------------
	=> All non-abstract methods of java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer.

	=> All non-abstract methods of java.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap.



Mediator
============
	=> Allows loose coupling by encapsulating the way disparate sets of objects 
	interact and communicate with each other.

	=>  Allows for the actions of each object set to vary independently of one another.

	=> Mediator design pattern is very helpful in an enterprise application where 
	multiple objects are interacting with each other. 

	=> If the objects interact with each other directly, the system components are tightly-coupled 
	with each other that makes higher maintainability cost and not hard to extend. 

	=> Mediator pattern focuses on provide a mediator between objects for communication 
	and help in implementing lose-coupling between objects.

	=> Air traffic controller is a great example of mediator pattern where the airport control room 
	works as a mediator for communication between different flights. 
	Mediator works as a router between objects and it can have it’s own logic to provide way of communication.

	=>Other example ESB bus in SOA

http://www.journaldev.com/1730/mediator-design-pattern-java


Strategy Pattern 
================
	=>The strategy pattern is intended to provide a means to define a family of algorithms, encapsulate each one '
	as an object, and make them interchangeable select algo at run time convert IS-A to HAS-A



command design pattern:
=======================
	=> command design pattern is used to implement loose coupling in a request-response model
	=> In command pattern, the request is send to the invoker and invoker
		 pass it to the encapsulated command object.
	=> Command object passes the request to the appropriate method of Receiver to perform the specific action.

	http://www.journaldev.com/1624/command-design-pattern


Interpreter Design Pattern
==========================

	=> Interpreter pattern is one of the behavioral design pattern and 
	is used to defines a grammatical representation for a language and provides 
	an interpreter to deal with this grammar. 

	The best example of this pattern is java compiler that interprets the java 
	source code into byte code that is understandable by JVM. Google Translator


	http://www.journaldev.com/1635/interpreter-design-pattern-in-java-example-tutorial




memento design pattern
=======================
	=> Memento design pattern is used when we want to save the state of an object 
	so that we can restore later on. Memento pattern is used to implement
	 this in such a way that the saved state data of the object is not accessible outside of the object, 
	this protects the integrity of saved state data.


	=> Originator is the object whose state needs to be saved and restored and it uses an inner class to save the
	 state of Object. The inner class is called Memento and it’s private,
	 so that it can’t be accessed from other objects.

	=> Caretaker is the helper class that is responsible for storing and restoring 
	the Originator’s state through Memento object. Since Memento is private to Originator, 
	Caretaker can’t access it and it’s stored as an Object within the caretaker.

	=> Example text editors where we can save it’s data anytime and use undo to restore it to previous saved state

http://www.journaldev.com/1734/memento-design-pattern-java


Creational patterns:
-------------------

Singleton Pattern 
Factory Pattern 
Abstract Factory Pattern
Builder Pattern 
Prototype Pattern 


structural patterns 
--------------------
Adapter Pattern 
	http://www.journaldev.com/1487/adapter-design-pattern-in-java-example-tutorial
Composite Pattern

Proxy Pattern
	http://www.oodesign.com/proxy-pattern.html

Flyweight Pattern
	http://www.oodesign.com/flyweight-pattern.html

Facade pattern
	http://www.oodesign.com/bridge-pattern.html
Bridge Pattern
	http://www.oodesign.com/bridge-pattern.html

Decorator Pattern 


Behaviour pattern
------------------
Template Method Pattern
	http://www.oodesign.com/template-method-pattern.html

Mediator Pattern

Chain of Responsibility Pattern
	http://www.journaldev.com/1617/chain-of-responsibility-design-pattern-in-java-example-tutorial

Observer Pattern
	http://www.oodesign.com/observer-pattern.html

Strategy Pattern

Command Pattern

State Pattern

Visitor Pattern

Interpreter Pattern

Iterator Pattern

Memento Pattern





















Selected topics:
-------------



serialization
-----------------------------------
How to serialization?

Serializable?

static data?

transient?

transient static?

Externalizable? 

We have to maintain order while doing de-serialization?
-------------------------------------------------------
We can do serialization of any no of object to the file, but order in which we serilize in same order we have 
to deserialize ( order is important)
 Eg: 
 
class Dog implements Serializable{}

class Cat implements Serializable{}
class Rat implements Serializable{}

if we serialized object of dog then cat and rat same order we have to follow while deserialization
	if dont know the order then use instanceOf operator
	
Object Grapth in serialization?
------------------------------------
Whenever we are serializing an object the set of all objects which 
are reachable from the object will be serialized automatically, 
this group of object is called "object graph"
In object graph every object should be serializable. 

If at least one object is not serializable we get RE NotSerializableException

class Dog implements Serializable{
	Cat cat=new Cat();
}

class Cat{
	Rat rat=new Rat();
}
class Rat implements Serializable{
	int i=5;
	int j=10;
}

Customized Serialization:
--------------------------
Need of customized serialization:
in default serialization there may be a loss of information
because of transient key word

class Account implements Serializable{
	String name="raj";
	transient String password="$##";
}
Customized Serialization:
--------------------------
private void writeObject(java.io.ObjectOutputStream stream)
---------------------------------------------------
 => This method will be executed automatically at the time of serialization
 => While performing serialization if we want to do any extera work we have to write corrosponding
    code in the method only.

 private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException 
 -----------------------------------------------------------------------------------------------------
 => This method will be executed automatically at the time of de-serialization
 => hence while performing de-serialization if we want to do any extra work we have to define
    the corresponding code in this method only. 

Note:
 	The above methods are callbacks methods as these methods are executed automatically by JVM



 private void writeObject(java.io.ObjectOutputStream oos)
	            throws IOException {
	      oos.defaultWriteObject();
	      String pw= "121"+password;
	      oos.writeObject(pw);
	    }

	    private void readObject(ObjectInputStream ois)
	            throws IOException, ClassNotFoundException {
	        ois.defaultReadObject();
	        String pw= (String) ois.readObject();
	        password =pw.substring(3);
	    }


Serialization with inheritance:
----------------------------------
If parent is seralizable then by default every child is 
Serializable. That is Seralizable is inheriting from Parent to Child.
 Hence every though child doesnt implements serializable if 
 parent class implements Serializable.


class Animal implements Ser{
	int i=10;
}
class Dog {
     int j=20;
}


Case 2: base is not serilizable but derived class is serializable?
-------------------------------------------------------------------
class Animal {
	int i=10;
}
class Dog implements Ser{
     int j=20;
}

	=> Even though parent class do not implements serializable interface we 
 can serialize child class object if child class implements serializable
 interface ie. to Serialize child class object, Parent class need not to be serializable.
 
 => At the time of serialization JVM will check is any instance variable is inheritated from 
Non serializable parent Or not. If any variable inherited from 
Non- serializable parent then JVM ignore original values and save default values to the file

 => At the time of de-serialization JVM will check is any parent class is not
  serializable or not. If any parent class is not- serializable 
  then JVM will execute instance control flow in that non-serializable parent and share it instance variable to the current

=> To execution instance control flow execution of non -serializable
 parent JVM will always invoked no argument constructors. 
 
 => Hence every non-serializable class should compulsory contain 
 no-argument constructors. Otherwise we will get RE ie InvalidClassException


Externalization 
-----------------------
	=> In serialization everything takes care by JVM and programmer 
	dont need to control. In Serialization total object will be 
	saved always to the file and it is not possible to save part of
	 the object which creates performance problems. 
	
	=> To overcome thsee problems we should go for Externalization where 
	everything taken care by programmer and JVM dont have any control.
	
	=> The main advantage of Externalization over Serialization is based on our
	 requirment we can save either total object or part of the object so that 
	 relatively performance is improved

	=> To provide externalization ability for any java object compulsory the 
	corrosponding class should implements Externalizable interface




























SOLID

http://cafe.elharo.com/programming/a-square-is-not-a-rectangle/

http://www.cdf.toronto.edu/~csc207h/fall/stg/lectures/eve/w10/


http://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/
http://www.informit.com/store/java-coding-guidelines-75-recommendations-for-reliable-9780321933157
